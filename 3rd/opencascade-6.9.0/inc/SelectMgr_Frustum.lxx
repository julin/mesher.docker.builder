// Created on: 2015-03-16
// Created by: Varvara POSKONINA
// Copyright (c) 2005-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

#include <NCollection_Vector.hxx>
#include <Poly_Array1OfTriangle.hxx>
#include <Standard_Assert.hxx>

#define DOT(A, B) (A.x() * B.x() + A.y() * B.y() + A.z() * B.z())
#define DOTp(A, B) (A.x() * B.X() + A.y() * B.Y() + A.z() * B.Z())

// =======================================================================
// function : isSeparated
// purpose  : Checks if AABB and frustum are separated along the given axis.
// =======================================================================
template <int N>
Standard_Boolean SelectMgr_Frustum<N>::isSeparated (const SelectMgr_Vec3& theBoxMin,
                                                    const SelectMgr_Vec3& theBoxMax,
                                                    const SelectMgr_Vec3& theDirect,
                                                    Standard_Boolean*     theInside) const
{
  const Standard_Real aMinB =
    theDirect.x() * (theDirect.x() < 0.0 ? theBoxMax.x() : theBoxMin.x()) +
    theDirect.y() * (theDirect.y() < 0.0 ? theBoxMax.y() : theBoxMin.y()) +
    theDirect.z() * (theDirect.z() < 0.0 ? theBoxMax.z() : theBoxMin.z());

  const Standard_Real aMaxB =
    theDirect.x() * (theDirect.x() < 0.0 ? theBoxMin.x() : theBoxMax.x()) +
    theDirect.y() * (theDirect.y() < 0.0 ? theBoxMin.y() : theBoxMax.y()) +
    theDirect.z() * (theDirect.z() < 0.0 ? theBoxMin.z() : theBoxMax.z());

  Standard_ASSERT_RAISE (aMaxB >= aMinB, "Error! Failed to project box");

  // frustum projection
  Standard_Real aMinF =  DBL_MAX;
  Standard_Real aMaxF = -DBL_MAX;

  for (Standard_Integer aVertIdx = 0; aVertIdx < N * 2; ++aVertIdx)
  {
    const Standard_Real aProj = DOT (myVertices[aVertIdx], theDirect);

    aMinF = Min (aMinF, aProj);
    aMaxF = Max (aMaxF, aProj);

    if (aMinF <= aMaxB && aMaxF >= aMinB)
    {
      if (theInside == NULL || !(*theInside)) // only overlap test
      {
        return Standard_False;
      }
    }
  }

  if (aMinF > aMaxB || aMaxF < aMinB)
  {
    return Standard_True; // fully separated
  }
  else if (theInside != NULL) // to check for inclusion?
  {
    *theInside &= aMinB >= aMinF && aMaxB <= aMaxF;
  }

  return Standard_False;
}

// =======================================================================
// function : isSeparated
// purpose  : Checks if triangle and frustum are separated along the
//            given axis
// =======================================================================
template <int N>
Standard_Boolean SelectMgr_Frustum<N>::isSeparated (const gp_Pnt& thePnt1,
                                                    const gp_Pnt& thePnt2,
                                                    const gp_Pnt& thePnt3,
                                                    const SelectMgr_Vec3& theAxis) const
{
  // frustum projection
  Standard_Real aMinF = RealLast();
  Standard_Real aMaxF = RealFirst();

  // triangle projection
  Standard_Real aMinTr = RealLast();
  Standard_Real aMaxTr = RealFirst();

  Standard_Real aTriangleProj;

  aTriangleProj = DOTp (theAxis, thePnt1);
  aMinTr = Min (aMinTr, aTriangleProj);
  aMaxTr = Max (aMaxTr, aTriangleProj);

  aTriangleProj = DOTp (theAxis, thePnt2);
  aMinTr = Min (aMinTr, aTriangleProj);
  aMaxTr = Max (aMaxTr, aTriangleProj);

  aTriangleProj = DOTp (theAxis, thePnt3);
  aMinTr = Min (aMinTr, aTriangleProj);
  aMaxTr = Max (aMaxTr, aTriangleProj);

  for (Standard_Integer aVertIter = 0; aVertIter < N * 2; ++aVertIter)
  {
    const Standard_Real aProj = DOT (myVertices[aVertIter], theAxis);

    aMinF = Min (aMinF, aProj);
    aMaxF = Max (aMaxF, aProj);

    if (aMinF <= aMaxTr && aMaxF >= aMinTr)
    {
      return Standard_False;
    }
  }

  return aMinF > aMaxTr || aMaxF < aMinTr;
}

// =======================================================================
// function : hasOverlap
// purpose  : Returns true if selecting volume is overlapped by
//            axis-aligned bounding box with minimum corner at point
//            theMinPnt and maximum at point theMaxPnt
// =======================================================================
template <int N>
Standard_Boolean SelectMgr_Frustum<N>::hasOverlap (const SelectMgr_Vec3& theMinPnt,
                                                   const SelectMgr_Vec3& theMaxPnt,
                                                   Standard_Boolean*     theInside)
{
  for (Standard_Integer anAxis = 0; anAxis < 3; ++anAxis)
  {
    if (theMinPnt[anAxis] > myMaxOrthoVertsProjections[anAxis]
     || theMaxPnt[anAxis] < myMinOrthoVertsProjections[anAxis])
    {
      return Standard_False; // fully separated
    }
    else if (theInside != NULL) // to check for inclusion?
    {
      *theInside &= theMinPnt[anAxis] >= myMinOrthoVertsProjections[anAxis]
                 && theMaxPnt[anAxis] <= myMaxOrthoVertsProjections[anAxis];
    }
  }

  const Standard_Integer anIncFactor = (myIsOrthographic && N == 4) ? 2 : 1;

  for (Standard_Integer aPlaneIdx = 0; aPlaneIdx < N + 1; aPlaneIdx += anIncFactor)
  {
    SelectMgr_Vec3 aPlane = myPlanes[aPlaneIdx];

    const Standard_Real aBoxProjMin =
      aPlane.x() * (aPlane.x() < 0.f ? theMaxPnt.x() : theMinPnt.x()) +
      aPlane.y() * (aPlane.y() < 0.f ? theMaxPnt.y() : theMinPnt.y()) +
      aPlane.z() * (aPlane.z() < 0.f ? theMaxPnt.z() : theMinPnt.z());

    const Standard_Real aBoxProjMax =
      aPlane.x() * (aPlane.x() < 0.f ? theMinPnt.x() : theMaxPnt.x()) +
      aPlane.y() * (aPlane.y() < 0.f ? theMinPnt.y() : theMaxPnt.y()) +
      aPlane.z() * (aPlane.z() < 0.f ? theMinPnt.z() : theMaxPnt.z());

    Standard_ASSERT_RAISE (aBoxProjMax >= aBoxProjMin, "Error! Failed to project box");

    if (aBoxProjMin > myMaxVertsProjections[aPlaneIdx]
     || aBoxProjMax < myMinVertsProjections[aPlaneIdx])
    {
      return Standard_False; // fully separated
    }
    else if (theInside != NULL) // to check for inclusion?
    {
      *theInside &= aBoxProjMin >= myMinVertsProjections[aPlaneIdx]
                 && aBoxProjMax <= myMaxVertsProjections[aPlaneIdx];
    }
  }

  for (Standard_Integer aDim = 0; aDim < 3; ++aDim)
  {
    SelectMgr_Vec3 anEdge1 (aDim == 0, aDim == 1, aDim == 2);

    for (Standard_Integer aVolDir = 0, aDirectionsNb = myIsOrthographic ? 4 : 6; aVolDir < aDirectionsNb; ++aVolDir)
    {
      SelectMgr_Vec3 aDirection (anEdge1.y() * myEdgeDirs[aVolDir].z() - anEdge1.z() * myEdgeDirs[aVolDir].y(),
                                 anEdge1.z() * myEdgeDirs[aVolDir].x() - anEdge1.x() * myEdgeDirs[aVolDir].z(),
                                 anEdge1.x() * myEdgeDirs[aVolDir].y() - anEdge1.y() * myEdgeDirs[aVolDir].x());

      if (isSeparated (theMinPnt, theMaxPnt, aDirection, theInside))
      {
        return Standard_False;
      }
    }
  }

  return Standard_True;
}

// =======================================================================
// function : hasOverlap
// purpose  : SAT intersection test between defined volume and given point
// =======================================================================
template <int N>
Standard_Boolean SelectMgr_Frustum<N>::hasOverlap (const gp_Pnt& thePnt)
{
  const Standard_Integer anIncFactor = (myIsOrthographic && N == 4) ? 2 : 1;

  for (Standard_Integer aPlaneIdx = 0; aPlaneIdx < N + 1; aPlaneIdx += anIncFactor)
  {
    const Select3D_Vec3& aPlane = myPlanes[aPlaneIdx];

    const Standard_Real aPointProj = aPlane.x() * thePnt.X() +
                                     aPlane.y() * thePnt.Y() +
                                     aPlane.z() * thePnt.Z();

    if (aPointProj > myMaxVertsProjections[aPlaneIdx]
     || aPointProj < myMinVertsProjections[aPlaneIdx])
    {
      return Standard_False;
    }
  }

  return Standard_True;
}

// =======================================================================
// function : hasOverlap
// purpose  : SAT intersection test between defined volume and given segment
// =======================================================================
template <int N>
Standard_Boolean SelectMgr_Frustum<N>::hasOverlap (const gp_Pnt& theStartPnt,
                                                   const gp_Pnt& theEndPnt)
{
  const SelectMgr_Vec3& aDir = SelectMgr_Vec3 (theEndPnt.X() - theStartPnt.X(),
                                               theEndPnt.Y() - theStartPnt.Y(),
                                               theEndPnt.Z() - theStartPnt.Z());
  if (std::sqrt (aDir.x() * aDir.x() + aDir.y() * aDir.y() + aDir.z () * aDir.z()) < Precision::Confusion())
    return Standard_True;

  const Standard_Integer anIncFactor = (myIsOrthographic && N == 4) ? 2 : 1;
  for (Standard_Integer aPlaneIdx = 0; aPlaneIdx < N + 1; aPlaneIdx += anIncFactor)
  {
    Standard_Real aMinSegm = RealLast(), aMaxSegm = RealFirst();
    Standard_Real aMinF    = RealLast(), aMaxF    = RealFirst();
    SelectMgr_Vec3 aPlane = myPlanes[aPlaneIdx];

    Standard_Real aProj1 = DOTp (aPlane, theStartPnt);
    Standard_Real aProj2 = DOTp (aPlane, theEndPnt);
    aMinSegm = Min (aProj1, aProj2);
    aMaxSegm = Max (aProj1, aProj2);

    aMaxF = myMaxVertsProjections[aPlaneIdx];
    aMinF = myMinVertsProjections[aPlaneIdx];

    if (aMinSegm > aMaxF
      || aMaxSegm < aMinF)
    {
      return Standard_False;
    }
  }

  Standard_Real aMin1 = DBL_MAX, aMax1 = -DBL_MAX;
  Standard_Real aMin2 = DBL_MAX, aMax2 = -DBL_MAX;
  for (Standard_Integer aVertIdx = 0; aVertIdx < N * 2; ++aVertIdx)
  {
    Standard_Real aProjection = DOT (aDir, myVertices[aVertIdx]);
    aMax2 = Max (aMax2, aProjection);
    aMin2 = Min (aMin2, aProjection);
  }
  Standard_Real aProj1 = DOTp (aDir, theStartPnt);
  Standard_Real aProj2 = DOTp (aDir, theEndPnt);
  aMin1 = Min (aProj1, aProj2);
  aMax1 = Max (aProj1, aProj2);
  if (aMin1 > aMax2
    || aMax1 < aMin2)
  {
    return Standard_False;
  }

  Standard_Integer aDirectionsNb = myIsOrthographic ? 4 : 6;
  for (Standard_Integer aEdgeDirIdx = 0; aEdgeDirIdx < aDirectionsNb; ++aEdgeDirIdx)
  {
    Standard_Real aMinSegm = DBL_MAX, aMaxSegm = -DBL_MAX;
    Standard_Real aMinF    = DBL_MAX, aMaxF    = -DBL_MAX;

    SelectMgr_Vec3 aTestDir = SelectMgr_Vec3 (aDir.y() * myEdgeDirs[aEdgeDirIdx].z() - aDir.z() * myEdgeDirs[aEdgeDirIdx].y(),
      aDir.z() * myEdgeDirs[aEdgeDirIdx].x() - aDir.x() * myEdgeDirs[aEdgeDirIdx].z(),
      aDir.x() * myEdgeDirs[aEdgeDirIdx].y() - aDir.y() * myEdgeDirs[aEdgeDirIdx].x());

    Standard_Real Proj1 = DOTp (aTestDir, theStartPnt);
    Standard_Real Proj2 = DOTp (aTestDir, theEndPnt);
    aMinSegm = Min (Proj1, Proj2);
    aMaxSegm = Max (Proj1, Proj2);

    for (Standard_Integer aVertIdx = 0; aVertIdx < N * 2; ++aVertIdx)
    {
      Standard_Real aProjection = DOT (aTestDir, myVertices[aVertIdx]);
      aMaxF = Max (aMaxF, aProjection);
      aMinF = Min (aMinF, aProjection);
    }

    if (aMinSegm > aMaxF
      || aMaxSegm < aMinF)
    {
      return Standard_False;
    }
  }

  return Standard_True;
}

// =======================================================================
// function : hasOverlap
// purpose  : SAT intersection test between frustum given and planar convex
//            polygon represented as ordered point set
// =======================================================================
template <int N>
Standard_Boolean SelectMgr_Frustum<N>::hasOverlap (const Handle(TColgp_HArray1OfPnt)& theArrayOfPnts,
                                                   SelectMgr_Vec3& theNormal)
{
  Standard_Integer aStartIdx = theArrayOfPnts->Lower();
  Standard_Integer anEndIdx = theArrayOfPnts->Upper();

  const gp_Pnt& aPnt1 = theArrayOfPnts->Value (aStartIdx);
  const gp_Pnt& aPnt2 = theArrayOfPnts->Value (aStartIdx + 1);
  const gp_Pnt& aPnt3 = theArrayOfPnts->Value (aStartIdx + 2);
  const gp_XYZ aVec1 = aPnt1.XYZ() - aPnt2.XYZ();
  const gp_XYZ aVec2 = aPnt3.XYZ() - aPnt2.XYZ();
  theNormal = SelectMgr_Vec3 (aVec2.Y() * aVec1.Z() - aVec2.Z() * aVec1.Y(),
                              aVec2.Z() * aVec1.X() - aVec2.X() * aVec1.Z(),
                              aVec2.X() * aVec1.Y() - aVec2.Y() * aVec1.X());
  Standard_Real aPolygProjection = DOTp (theNormal, aPnt1);

  Standard_Real aMax = RealFirst();
  Standard_Real aMin = RealLast();
  for (Standard_Integer aVertIdx = 0; aVertIdx < N * 2; ++aVertIdx)
  {
    Standard_Real aProjection = DOT (theNormal, myVertices[aVertIdx]);
    aMax = Max (aMax, aProjection);
    aMin = Min (aMin, aProjection);
  }
  if (aPolygProjection > aMax
    || aPolygProjection < aMin)
  {
    return Standard_False;
  }

  Standard_Integer aPlanesNb = N == 4 ? N + 2 : N + 1;
  for (Standard_Integer aPlaneIdx = 0; aPlaneIdx < aPlanesNb; ++aPlaneIdx)
  {
    Standard_Real aMaxF = RealFirst();
    Standard_Real aMinF = RealLast();
    Standard_Real aMaxPolyg = RealFirst();
    Standard_Real aMinPolyg = RealLast();
    SelectMgr_Vec3 aPlane = myPlanes[aPlaneIdx];
    for (Standard_Integer aPntIter = aStartIdx; aPntIter <= anEndIdx; ++aPntIter)
    {
      Standard_Real aProjection = DOTp (aPlane, theArrayOfPnts->Value (aPntIter));
      aMaxPolyg = Max (aMaxPolyg, aProjection);
      aMinPolyg = Min (aMinPolyg, aProjection);
    }
    aMaxF = myMaxVertsProjections[aPlaneIdx];
    aMinF = myMinVertsProjections[aPlaneIdx];
    if (aMinPolyg > aMaxF
      || aMaxPolyg < aMinF)
    {
      return Standard_False;
    }
  }

  Standard_Integer aDirectionsNb = myIsOrthographic ? 4 : 6;
  for (Standard_Integer aPntsIter = aStartIdx; aPntsIter <= anEndIdx; ++aPntsIter)
  {
    const gp_XYZ aSegmDir = aPntsIter == anEndIdx ? theArrayOfPnts->Value (aStartIdx).XYZ() - theArrayOfPnts->Value (anEndIdx).XYZ()
                                             : theArrayOfPnts->Value (aPntsIter + 1).XYZ() - theArrayOfPnts->Value (aPntsIter).XYZ();
    for (Standard_Integer aVolDir = 0; aVolDir < aDirectionsNb; ++aVolDir)
    {
      Standard_Real aMaxPolyg = RealFirst();
      Standard_Real aMinPolyg = RealLast();
      Standard_Real aMaxF = RealFirst();
      Standard_Real aMinF = RealLast();
      SelectMgr_Vec3 aTestDir = SelectMgr_Vec3 (aSegmDir.Y() * myEdgeDirs[aVolDir].z() - aSegmDir.Z() * myEdgeDirs[aVolDir].y(),
                                                aSegmDir.Z() * myEdgeDirs[aVolDir].x() - aSegmDir.X() * myEdgeDirs[aVolDir].z(),
                                                aSegmDir.X() * myEdgeDirs[aVolDir].y() - aSegmDir.Y() * myEdgeDirs[aVolDir].x());

      for (Standard_Integer aPntIter = aStartIdx; aPntIter <= anEndIdx; ++aPntIter)
      {
        Standard_Real aProjection = DOTp (aTestDir, theArrayOfPnts->Value (aPntIter));
        aMaxPolyg = Max (aMaxPolyg, aProjection);
        aMinPolyg = Min (aMinPolyg, aProjection);
      }

      for (Standard_Integer aVertIdx = 0; aVertIdx < N * 2; ++aVertIdx)
      {
        Standard_Real aProjection = DOT (aTestDir, myVertices[aVertIdx]);
        aMaxF = Max (aMaxF, aProjection);
        aMinF = Min (aMinF, aProjection);
      }

      if (aMinPolyg > aMaxF
        || aMaxPolyg < aMinF)
      {
        return Standard_False;
      }
    }
  }

  return Standard_True;
}

// =======================================================================
// function : hasOverlap
// purpose  : SAT intersection test between defined volume and given triangle
// =======================================================================
template <int N>
Standard_Boolean SelectMgr_Frustum<N>::hasOverlap (const gp_Pnt& thePnt1,
                                                   const gp_Pnt& thePnt2,
                                                   const gp_Pnt& thePnt3,
                                                   SelectMgr_Vec3& theNormal)
{

  SelectMgr_Vec3 aPnt1 (thePnt1.X(), thePnt1.Y(), thePnt1.Z());
  SelectMgr_Vec3 aPnt2 (thePnt2.X(), thePnt2.Y(), thePnt2.Z());
  SelectMgr_Vec3 aPnt3 (thePnt3.X(), thePnt3.Y(), thePnt3.Z());
  SelectMgr_Vec3 aTrEdges[3] = { aPnt2 - aPnt1,
                                 aPnt3 - aPnt2,
                                 aPnt1 - aPnt3 };

  const Standard_Integer anIncFactor = (myIsOrthographic && N == 4) ? 2 : 1;
  for (Standard_Integer aPlaneIdx = 0; aPlaneIdx < N + 1; aPlaneIdx += anIncFactor)
  {
    SelectMgr_Vec3 aPlane = myPlanes[aPlaneIdx];
    Standard_Real aTriangleProj;

    aTriangleProj = DOT (aPlane, aPnt1);
    Standard_Real aTriangleProjMin = aTriangleProj;
    Standard_Real aTriangleProjMax = aTriangleProj;

    aTriangleProj = DOT (aPlane, aPnt2);
    aTriangleProjMin = Min (aTriangleProjMin, aTriangleProj);
    aTriangleProjMax = Max (aTriangleProjMax, aTriangleProj);

    aTriangleProj = DOT (aPlane, aPnt3);
    aTriangleProjMin = Min (aTriangleProjMin, aTriangleProj);
    aTriangleProjMax = Max (aTriangleProjMax, aTriangleProj);

    Standard_Real aFrustumProjMax = myMaxVertsProjections[aPlaneIdx];
    Standard_Real aFrustumProjMin = myMinVertsProjections[aPlaneIdx];
    if (aTriangleProjMin > aFrustumProjMax
      || aTriangleProjMax < aFrustumProjMin)
    {
      return Standard_False;
    }
  }

  theNormal = SelectMgr_Vec3 (aTrEdges[2].y() * aTrEdges[0].z() - aTrEdges[2].z() * aTrEdges[0].y(),
                              aTrEdges[2].z() * aTrEdges[0].x() - aTrEdges[2].x() * aTrEdges[0].z(),
                              aTrEdges[2].x() * aTrEdges[0].y() - aTrEdges[2].y() * aTrEdges[0].x());
  if (isSeparated (thePnt1, thePnt2, thePnt3, theNormal))
  {
    return Standard_False;
  }

  Standard_Integer aDirectionsNb = myIsOrthographic ? 4 : 6;
  for (Standard_Integer aTriangleEdgeIdx = 0; aTriangleEdgeIdx < 3; ++aTriangleEdgeIdx)
  {
    for (Standard_Integer aVolDir = 0; aVolDir < aDirectionsNb; ++aVolDir)
    {
      SelectMgr_Vec3 anEdge1 = myEdgeDirs[aVolDir];
      SelectMgr_Vec3 anEdge2 = aTrEdges[aTriangleEdgeIdx];
      SelectMgr_Vec3 aTestDirection = SelectMgr_Vec3 (
        anEdge1.y() * anEdge2.z() - anEdge1.z() * anEdge2.y(),
        anEdge1.z() * anEdge2.x() - anEdge1.x() * anEdge2.z(),
        anEdge1.x() * anEdge2.y() - anEdge1.y() * anEdge2.x());

      if (isSeparated (thePnt1, thePnt2, thePnt3, aTestDirection))
      {
        return Standard_False;
      }
    }
  }

  return Standard_True;
}

#undef DOT
#undef DOTp
